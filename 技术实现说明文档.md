# 智能停车系统技术实现说明文档

## 目录
1. [技术栈](#技术栈)
2. [系统架构](#系统架构)
3. [功能模块实现详解](#功能模块实现详解)
4. [前后端交互流程](#前后端交互流程)
5. [数据库设计](#数据库设计)
6. [核心业务逻辑](#核心业务逻辑)

---

## 技术栈

### 后端技术栈

#### 编程语言与框架
- **Go 1.24.0+**：主要编程语言
- **Gin Framework v1.11.0**：HTTP Web 框架，提供路由、中间件等功能
- **GORM v1.31.0**：ORM 框架，用于数据库操作
- **MySQL Driver v1.6.0**：MySQL 数据库驱动

#### 数据库与缓存
- **MySQL 5.7+**：关系型数据库，存储业务数据
- **Redis v9.14.0**：内存数据库，用于缓存和会话管理

#### 认证与安全
- **JWT (golang-jwt/jwt/v5 v5.3.0)**：JSON Web Token，用于用户和管理员认证
- **bcrypt (golang.org/x/crypto)**：密码加密算法

#### 配置管理
- **YAML (gopkg.in/yaml.v3)**：配置文件解析
- **godotenv (github.com/joho/godotenv)**：环境变量管理

#### 其他工具
- **日志系统**：自定义日志包，记录系统运行日志

### 前端技术栈

#### 框架与语言
- **Qt 6.8.0+**：跨平台应用框架
- **QML (Qt Quick)**：声明式 UI 语言，用于构建用户界面
- **C++17**：底层逻辑实现语言

#### Qt 模块
- **Qt6::Core**：核心功能模块
- **Qt6::Network**：网络请求模块（QNetworkAccessManager）
- **Qt6::Quick**：QML 引擎
- **Qt6::QuickControls2**：UI 控件库（Material 风格）

#### 构建工具
- **CMake 3.21+**：构建系统
- **Ninja**：构建后端

---

## 系统架构

### 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        前端层 (Qt6/QML)                       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐    │
│  │ 登录页面  │  │ 用户主页  │  │ 管理员页  │  │ 其他页面  │    │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘    │
│       │             │             │             │          │
│       └─────────────┴─────────────┴─────────────┘          │
│                          │                                   │
│                    ┌─────▼─────┐                            │
│                    │ ApiClient │                            │
│                    │  (C++/Qt) │                            │
│                    └─────┬─────┘                            │
└──────────────────────────┼──────────────────────────────────┘
                           │ HTTP/JSON
                           │
┌──────────────────────────▼──────────────────────────────────┐
│                     后端层 (Go/Gin)                          │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                   路由层 (Router)                      │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │  │
│  │  │ 用户路由  │  │ 管理员路由│  │ 停车路由  │          │  │
│  │  └────┬─────┘  └────┬─────┘  └────┬─────┘          │  │
│  └───────┼─────────────┼─────────────┼─────────────────┘  │
│          │             │             │                      │
│  ┌───────▼─────────────▼─────────────▼──────────────┐    │
│  │              中间件层 (Middleware)                  │    │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐        │    │
│  │  │ CORS中间件│  │ 用户认证  │  │ 管理员认证│        │    │
│  │  └──────────┘  └──────────┘  └──────────┘        │    │
│  └────────────────────────────────────────────────────┘    │
│          │                                                  │
│  ┌───────▼──────────────────────────────────────────────┐  │
│  │              控制器层 (Controller)                     │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │  │
│  │  │用户控制器 │  │停车控制器 │  │支付控制器 │          │  │
│  │  └────┬─────┘  └────┬─────┘  └────┬─────┘          │  │
│  └───────┼─────────────┼─────────────┼─────────────────┘  │
│          │             │             │                      │
│  ┌───────▼─────────────▼─────────────▼──────────────┐    │
│  │              服务层 (Service)                       │    │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐        │    │
│  │  │预订服务   │  │支付服务   │  │违规服务   │        │    │
│  │  └────┬─────┘  └────┬─────┘  └────┬─────┘        │    │
│  └───────┼─────────────┼─────────────┼────────────────┘    │
│          │             │             │                      │
│  ┌───────▼─────────────▼─────────────▼──────────────┐    │
│  │              数据访问层 (Repository)                 │    │
│  └────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
┌───────▼──────┐  ┌────────▼────────┐  ┌─────▼──────┐
│   MySQL      │  │     Redis       │  │   日志文件   │
│   数据库      │  │    缓存         │  │            │
└──────────────┘  └─────────────────┘  └────────────┘
```

### 分层架构说明

1. **前端层**：Qt6/QML 应用，负责用户界面展示和交互
2. **API 层**：HTTP RESTful API，前后端通信接口
3. **路由层**：Gin 路由，负责请求分发
4. **中间件层**：CORS、认证等横切关注点
5. **控制器层**：处理 HTTP 请求，参数验证
6. **服务层**：业务逻辑实现
7. **数据访问层**：数据库操作封装
8. **数据存储层**：MySQL（持久化）、Redis（缓存）

---

## 功能模块实现详解

### 1. 用户认证模块

#### 1.1 用户注册

**前端实现**：
- **文件**：`smartparkingui/ui/LoginPage.qml`
- **API 调用**：`ApiClient::registerUser()`
- **位置**：`smartparkingui/src/apiclient.cpp:244-250`

**后端实现**：
- **接口**：`POST /api/v1/register`
- **控制器**：`controller.Register()` 
- **文件**：`smart_parking_backend/internal/controller/user_controller.go`
- **实现逻辑**：
  1. 接收用户信息和车辆列表
  2. 验证用户名长度（3-50字符）、密码长度（≥6字符）
  3. 使用 bcrypt 加密密码
  4. 创建用户记录（Users_list 表）
  5. 批量创建车辆记录（Vehicle 表）
  6. 返回用户ID和注册的车辆数量

**数据流**：
```
前端 → POST /api/v1/register → Register() → GORM → MySQL
                                    ↓
                               bcrypt加密密码
                                    ↓
                            创建用户+车辆记录
```

#### 1.2 用户登录

**前端实现**：
- **文件**：`smartparkingui/ui/LoginPage.qml`
- **API 调用**：`ApiClient::login()` 或 `ApiClient::sendLoginCode()`
- **位置**：`smartparkingui/src/apiclient.cpp:259-270`

**后端实现**：
- **密码登录接口**：`POST /api/v1/login`
- **验证码登录接口**：`POST /api/v1/send_code` + `POST /api/v1/login`
- **控制器**：
  - `controller.SendLoginCode()` - 发送验证码
  - `controller.Login()` - 登录处理
- **文件**：`smart_parking_backend/internal/controller/user_controller.go`
- **实现逻辑**：

  **验证码登录流程**：
  1. 调用 `POST /api/v1/send_code`，传入手机号
  2. 后端生成6位随机验证码
  3. 验证码存入 Redis，key: `login_code:{phone}`，过期时间5分钟
  4. 限制：60秒内只能发送一次（Redis 检查）
  5. 前端输入验证码，调用 `POST /api/v1/login`，传入 `phone` 和 `code`
  6. 后端从 Redis 读取验证码并验证
  7. 验证通过后，查询用户信息
  8. 生成 JWT Token（包含 user_id）
  9. 更新用户 last_login 时间
  10. 返回用户信息和 Token

  **密码登录流程**：
  1. 调用 `POST /api/v1/login`，传入 `phone` 和 `password`
  2. 查询用户记录
  3. 使用 bcrypt 验证密码
  4. 生成 JWT Token
  5. 更新 last_login
  6. 返回用户信息和 Token

**数据流**：
```
前端 → POST /api/v1/send_code → SendLoginCode() → Redis存储验证码
前端 → POST /api/v1/login → Login() → 验证码/密码验证 → 生成JWT → 返回Token
```

#### 1.3 管理员登录

**后端实现**：
- **接口**：`POST /admin/login`
- **控制器**：`controller.AdminLoginController`
- **实现逻辑**：
  1. 验证手机号和密码
  2. 查询管理员表（Admin）
  3. 验证密码
  4. 生成管理员 JWT Token（包含 admin_id、role、lot_id）
  5. 返回管理员信息和 Token

**认证中间件**：
- **用户认证**：`middleware.UserAuthMiddleware()`
- **管理员认证**：`middleware.AdminAuthMiddleware()`
- **文件**：`smart_parking_backend/internal/middleware/userauth.go`、`adminauth.go`
- **实现逻辑**：
  1. 从请求头提取 `Authorization: Bearer {token}`
  2. 解析 JWT Token
  3. 验证 Token 有效性
  4. 将用户ID/管理员ID写入 Gin Context
  5. 后续控制器从 Context 获取用户信息

---

### 2. 车辆管理模块

#### 2.1 获取用户车辆列表

**前端实现**：
- **API 调用**：`ApiClient::getUserVehicles()`
- **位置**：`smartparkingui/src/apiclient.cpp:286-289`

**后端实现**：
- **接口**：`GET /api/v1/vehicles`
- **控制器**：`controller.GetUserVehicles()`
- **实现逻辑**：
  1. 从 JWT Token 中提取 user_id（中间件已处理）
  2. 查询 Vehicle 表，条件：`user_id = ?`
  3. 返回车辆列表

#### 2.2 添加车辆

**后端实现**：
- **接口**：`POST /api/v1/vehicles`
- **控制器**：`controller.AddUserVehicle()`
- **实现逻辑**：
  1. 从 Token 获取 user_id
  2. 验证车牌号唯一性
  3. 创建车辆记录
  4. 返回创建的车辆信息

#### 2.3 删除车辆

**后端实现**：
- **接口**：`DELETE /api/v1/vehicles/:id`
- **控制器**：`controller.DeleteUserVehicle()`
- **实现逻辑**：
  1. 验证车辆属于当前用户
  2. 使用 GORM 级联删除（OnDelete:CASCADE）
  3. 自动删除相关预订、停车记录、违规记录

---

### 3. 停车场管理模块

#### 3.1 获取停车场列表

**后端实现**：
- **接口**：`GET /api/v2/getparkinglots`
- **控制器**：`controller.GetAllParkingLots()`
- **实现逻辑**：
  1. 查询 ParkingLot 表
  2. 关联查询 ParkingSpace 表
  3. 返回停车场列表及车位信息

#### 3.2 添加停车场

**后端实现**：
- **接口**：`POST /api/v2/addparkinglot`
- **控制器**：`controller.AddParkingLot()`
- **实现逻辑**：
  1. 接收停车场信息（名称、地址、层数、车位数、费率等）
  2. 创建 ParkingLot 记录
  3. 返回创建的停车场信息

#### 3.3 车位管理

**添加车位**：
- **接口**：`POST /api/v2/addparkingspace`
- **控制器**：`controller.AddParkingSpace()`
- **实现逻辑**：
  1. 接收车位信息（停车场ID、楼层、编号、类型、状态）
  2. 创建 ParkingSpace 记录
  3. 返回创建的车位信息

**更新车位状态**：
- **接口**：`PATCH /api/v2/updatespacestatus/:id`
- **控制器**：`controller.UpdateSpaceStatus()`
- **实现逻辑**：
  1. 接收更新参数（status、is_occupied、is_reserved）
  2. 更新 ParkingSpace 记录
  3. 返回更新后的车位信息

---

### 4. 预订模块

#### 4.1 创建预订

**前端实现**：
- **文件**：`smartparkingui/ui/BookingPage.qml`
- **API 调用**：`ApiClient::createBooking()`
- **位置**：`smartparkingui/src/apiclient.cpp:433-445`

**后端实现**：
- **接口**：`POST /api/v4/booking/create`
- **控制器**：`booking.Handler.CreateBooking()`
- **服务层**：`booking.Service.CreateBooking()`
- **文件**：
  - `smart_parking_backend/internal/booking/handler.go`
  - `smart_parking_backend/internal/booking/service.go`
- **实现逻辑**：
  1. 接收预订参数（user_id、vehicle_id、lot_id、start_time、end_time、space_type）
  2. 调用 `Service.CreateBooking()`：
     - 查找可用车位（`FindAvailableSlot()`）
     - 验证时间有效性（结束时间必须晚于开始时间）
     - 计算预订时长（分钟）
     - 生成预订编号（格式：`RES-{userID}-{timestamp}`）
     - 创建 ReservationOrder 记录（status=1 已预订）
     - 标记车位为已预订（`is_reserved=1`）
  3. 返回创建的预订订单信息

**数据流**：
```
前端 → POST /api/v4/booking/create → Handler → Service.CreateBooking()
                                                      ↓
                                              查找可用车位
                                                      ↓
                                              创建预订订单
                                                      ↓
                                              更新车位状态
```

#### 4.2 取消预订

**后端实现**：
- **接口**：`DELETE /api/v4/booking/cancel/:id`
- **控制器**：`booking.Handler.CancelBooking()`
- **实现逻辑**：
  1. 验证预订订单存在且属于当前用户
  2. 检查预订状态（只能取消"已预订"状态的订单）
  3. 更新预订状态为"已取消"（status=0）
  4. 释放车位（`is_reserved=0`）
  5. 返回取消结果

#### 4.3 查询用户预订列表

**后端实现**：
- **接口**：`GET /api/v4/booking/user?user_id={id}`
- **控制器**：`booking.Handler.GetUserBookings()`
- **实现逻辑**：
  1. 查询 ReservationOrder 表，条件：`user_id = ?`
  2. 关联查询车辆、停车场、车位信息
  3. 返回预订列表（包含所有状态：已预订、使用中、已完成、已取消）

#### 4.4 检查并更新超时预订

**后端实现**：
- **接口**：`POST /api/v4/booking/check-expired`
- **控制器**：`booking.Handler.CheckAndUpdateExpiredBookings()`
- **实现逻辑**：
  1. 查找所有超过结束时间且状态为"已预订"或"使用中"的预订
  2. 批量更新状态为"已取消"（status=0）
  3. 设置 `actual_end_time` 为当前时间
  4. 释放关联车位（`is_reserved=0`）
  5. 返回更新的记录数量

---

### 5. 停车模块

#### 5.1 车辆入场

**前端实现**：
- **文件**：`smartparkingui/ui/ParkingEntryPage.qml`
- **API 调用**：`ApiClient::vehicleEntry()`
- **位置**：`smartparkingui/src/apiclient.cpp:340-351`

**后端实现**：
- **接口**：`POST /api/parking/entry`
- **控制器**：`controller.VehicleEntry()`
- **文件**：`smart_parking_backend/internal/controller/user_parking.go`
- **实现逻辑**：
  1. 根据车牌号查找车辆和用户信息
  2. **检查有效预订**：
     - 查找该车辆在当前时间段的有效预订（status=1，允许提前30分钟入场）
     - 如果找到预订，使用预订的车位，更新预订状态为"使用中"（status=2）
  3. **无预订时分配车位**：
     - 根据车位类型查找可用车位（`is_occupied=0` 且 `is_reserved=0`）
     - 如果指定类型无可用车位，降级为普通车位
  4. **创建停车记录**：
     - 创建 ParkingRecord 记录（record_status=1 在场）
     - 记录入场时间（entry_time）
     - 关联预订ID（如果有）
  5. **更新车位状态**：
     - 标记车位为已占用（`is_occupied=1`）
  6. 返回停车记录信息

**数据流**：
```
前端 → POST /api/parking/entry → VehicleEntry()
                                      ↓
                              查找车辆和用户
                                      ↓
                          ┌───────────┴───────────┐
                          │                       │
                    有有效预订？              无预订
                          │                       │
                    使用预订车位            分配空闲车位
                          │                       │
                    更新预订状态=2         创建停车记录
                          │                       │
                          └───────────┬───────────┘
                                      ↓
                              更新车位状态
```

#### 5.2 检查有效预订（入场前）

**后端实现**：
- **接口**：`POST /api/parking/check-reservation`
- **控制器**：`controller.CheckValidReservation()`
- **实现逻辑**：
  1. 根据车牌号查找车辆
  2. 查找有效预订：
     - 当前时间在预订时间段内（允许提前30分钟）
     - 状态为"已预订"（status=1）
     - 如果提供了 lot_id，同时匹配停车场ID
  3. 返回预订信息、车位信息、停车场信息
  4. 如果没有有效预订，返回 `has_reservation: false`

#### 5.3 车辆离场

**前端实现**：
- **API 调用**：`ApiClient::vehicleExit()`
- **位置**：`smartparkingui/src/apiclient.cpp:353-358`

**后端实现**：
- **接口**：`POST /api/parking/exit`
- **控制器**：`controller.VehicleExit()`
- **实现逻辑**（在数据库事务中执行）：
  1. **查找停车记录**：
     - 根据车牌号查找状态为"在场"（record_status=1）的停车记录
  2. **计算费用**：
     - 计算停车时长（从 entry_time 到当前时间）
     - 根据停车时长和停车场费率计算停车费（向上取整，不足1小时按1小时计）
     - 检查违规记录，计算违规罚款
     - 总费用 = 停车费 + 违规罚款
  3. **更新停车记录**：
     - 设置出场时间（exit_time）
     - 更新停车时长（duration_minute）
     - 设置计算费用（fee_calculated）
     - 更新状态为"已出场"（record_status=2）
     - 如果有违规，设置 `is_violation=1`
  4. **释放车位**：
     - 标记车位为未占用（`is_occupied=0`）
  5. **处理预订**：
     - 如果停车记录关联了预订，更新预订状态为"已完成"（status=3）
     - 设置 `actual_end_time` 为当前时间
  6. **生成支付**：
     - 调用支付服务创建支付单（type="parking"）
     - 生成模拟支付链接
  7. 返回停车记录和支付链接

**数据流**：
```
前端 → POST /api/parking/exit → VehicleExit()
                                      ↓
                              查找停车记录
                                      ↓
                              计算停车费用
                                      ↓
                          ┌───────────┴───────────┐
                          │                       │
                    检查违规记录              更新停车记录
                          │                       │
                    计算违规罚款              释放车位
                          │                       │
                          └───────────┬───────────┘
                                      ↓
                              更新预订状态
                                      ↓
                              创建支付单
```

#### 5.4 获取用户在场停车记录

**后端实现**：
- **接口**：`GET /api/parking/:user_id/active-parking`
- **控制器**：`controller.GetUserActiveParkingRecords()`
- **实现逻辑**：
  1. 查询 ParkingRecord 表，条件：`user_id = ? AND record_status = 1`
  2. 关联查询车辆、车位、停车场信息（使用 `Preload("Vehicle")` 预加载车辆信息）
  3. 返回在场停车记录数组（如果没有记录，返回空数组 `[]`）
  4. **注意**：后端返回的车辆信息中，车牌号字段为 `LicensePlate`（首字母大写），前端需要兼容处理

**前端实现**：
- **文件**：`smartparkingui/ui/UserMainPage.qml`
- **功能特性**：
  1. **多车辆独立显示**：为用户的每一辆车显示独立的状态卡片
  2. **独立操作按钮**：每辆车都有专属的"停车"和"离场"按钮
  3. **状态实时更新**：停车或离场后自动刷新状态，不影响其他车辆的操作
  4. **数据合并逻辑**：
     - 获取用户所有车辆列表（`GET /api/v1/vehicles`）
     - 获取所有在场停车记录（`GET /api/parking/:user_id/active-parking`）
     - 通过车牌号匹配，为每辆车设置停车状态（`isParking`）
  5. **车牌号字段处理**：
     - 后端 Vehicle 模型的 JSON 标签是 `LicensePlate`（首字母大写）
     - 前端需要检查 `record.vehicle.LicensePlate`、`record.vehicle.licensePlate`、`record.vehicle.license_plate` 等多种格式
     - 确保能正确提取车牌号进行匹配

---

### 6. 支付模块

#### 6.1 统一支付接口

**后端实现**：
- **接口**：`POST /api/payment/create`
- **控制器**：`payment.Handler.CreatePaymentRedirectHandler()`
- **文件**：`smart_parking_backend/internal/payment/handler.go`
- **实现逻辑**：

  **预订支付（type="reservation"）**：
  1. 验证预订订单存在、未支付、未取消
  2. 金额：优先使用传入的 `amount`，否则使用订单的 `total_fee`
  3. 调用 `bookingSvc.CreatePendingPayment()` 创建待支付记录
  4. 生成支付链接

  **停车支付（type="parking"）**：
  1. 验证停车记录存在
  2. 金额：优先使用传入的 `amount`，否则使用记录的 `fee_calculated`
  3. 使用原生SQL插入支付记录（临时禁用外键检查）
  4. TransactionNo格式：`PENDING_{record_id}_{timestamp}`

  **违规支付（type="violation"）**：
  1. 验证违规记录存在且未处理
  2. 金额：优先使用传入的 `amount`，否则使用违规记录的 `fine_amount`
  3. 使用原生SQL插入支付记录
  4. TransactionNo格式：`PENDING_VIO_{violation_id}_{timestamp}`

  5. 生成模拟支付链接：`http://127.0.0.1:8081/simulate_payment?provider={method}&payment_id={payment_id}`

#### 6.2 支付回调

**后端实现**：
- **接口**：`POST /api/payment/notify`
- **控制器**：`payment.Handler.NotifyHandler()`
- **实现逻辑**：
  1. **查找支付记录**：根据 `payment_id` 查找支付记录
  2. **检查状态**：如果已支付，直接返回成功（幂等性）
  3. **验证交易号**：检查 `transaction_no` 是否已存在
  4. **更新支付记录**：
     - 设置 `payment_status=1`（已支付）
     - 更新 `transaction_no`、`method`、`amount`
     - 设置 `pay_time` 为当前时间
  5. **更新业务记录**（根据 TransactionNo 前缀判断）：
     - **违规支付**（前缀 `PENDING_VIO_`）：更新 ViolationRecord 的 `status=1`（已处理）
     - **预订支付**：调用 `bookingSvc.PayBooking()` 更新订单状态
     - **停车支付**：更新 ParkingRecord 的 `payment_status=1` 和 `fee_paid`
  6. 返回成功结果

**数据流**：
```
支付页面 → POST /api/payment/notify → NotifyHandler()
                                          ↓
                                    更新支付记录
                                          ↓
                          ┌───────────────┼───────────────┐
                          │               │               │
                    违规支付          预订支付        停车支付
                          │               │               │
                    更新违规状态      更新订单状态    更新停车记录
```

#### 6.3 获取用户支付记录

**后端实现**：
- **接口**：`GET /api/v1/getpaymentinfo?page={page}&page_size={size}`
- **控制器**：`controller.GetUserPaymentRecords()`
- **实现逻辑**：
  1. 从 JWT Token 获取 user_id
  2. 分页查询 PaymentRecord 表
  3. **识别订单类型**：
     - 通过 `transaction_no` 前缀判断：`PENDING_VIO_` → 违规订单
     - 通过关联查询判断：关联 ReservationOrder → 预订订单
     - 否则为停车订单
  4. **查询订单详情**：
     - 预订订单：查询 ReservationOrder 详情
     - 停车订单：查询 ParkingRecord 详情（包含车辆、停车场信息）
     - 违规订单：查询 ViolationRecord 详情
  5. 返回支付记录列表（包含订单类型和详细信息）

---

### 7. 违规模块

#### 7.1 检查违规行为（批处理）

**后端实现**：
- **接口**：`POST /api/violations/check`
- **控制器**：`controller.CheckViolations()`
- **实现逻辑**：
  1. 根据 `check_type` 参数执行不同的检查：
     - `1`：预订未使用（预订时间已过但未入场）
     - `2`：超时停车（停车时间超过预订时间）
     - `3`：未支付停车费（离场后未支付）
     - `4`：未支付罚款
  2. 扫描数据库，查找符合条件的记录
  3. 创建 ViolationRecord 记录
  4. 更新相关订单/记录状态
  5. 返回生成的违规记录数量

**注意**：此接口主要用于定时任务或运维入口，普通用户不直接调用。

#### 7.2 查询用户违规记录

**后端实现**：
- **接口**：`GET /api/violations/checkmyself/:user_id`
- **控制器**：`controller.GetUserViolationHistory()`
- **实现逻辑**：
  1. 查询 ViolationRecord 表，条件：`user_id = ?`
  2. 关联查询停车记录、车辆、用户信息
  3. 返回违规记录列表（包含所有状态：未处理、已处理）

#### 7.3 支付罚款

**后端实现**：
- **接口**：`POST /api/violations/:violation_id/pay`
- **控制器**：`controller.PayViolationFine()`
- **实现逻辑**：
  1. 验证违规记录存在且未处理
  2. 调用支付服务创建支付单（type="violation"）
  3. 生成支付链接
  4. 返回支付信息

---

### 8. 管理员数据分析模块

#### 8.1 车位使用率分析

**后端实现**：
- **接口**：`GET /admin/occupancy?start_time={start}&end_time={end}`
- **控制器**：`controller.ParkingSpaceOccupancyAnalysis()`
- **实现逻辑**：
  1. 从 JWT Token 获取管理员信息（role、lot_id）
  2. 根据时间范围查询停车记录
  3. **统计指标**：
     - 总车位数、已占用车位数、已预订车位数
     - 使用率 = (已占用 + 已预订) / 总车位数
     - 总收入、日均收入、平均停车时长
     - 按车位类型分组统计（普通、充电桩等）
  4. 返回统计数据（JSON格式）

#### 8.2 违规行为分析

**后端实现**：
- **接口**：`GET /admin/violations?year={year}&month={month}`
- **控制器**：`controller.ViolationAnalysis()`
- **实现逻辑**：
  1. 从 Token 获取管理员信息
  2. 根据年份、月份查询违规记录
  3. **统计指标**：
     - 违规总数
     - 按违规类型分组统计（超时停车、预订未使用、未支付停车费）
     - 按处理状态分组统计（未处理、已处理）
     - 罚款总额、已收罚款
     - 月度趋势分析
  4. 返回统计数据

#### 8.3 报表生成

**后端实现**：
- **接口**：`GET /admin/report?type={type}&year={year}&month={month}`
- **控制器**：`controller.GenerateReport()`
- **实现逻辑**：
  1. 根据报表类型（monthly/annual）和时间范围查询数据
  2. **报表内容**：
     - 停车统计（总停车次数、总时长、总收入）
     - 违规统计（违规数量、罚款金额）
     - 收入统计（总收入、日均收入、峰值时段）
     - 使用率统计（平均使用率、峰值使用率）
     - 高峰时段分析
  3. 返回完整报表数据（JSON格式）

---

## 前后端交互流程

### 1. 用户登录流程

```
┌─────────┐                    ┌─────────┐                    ┌─────────┐
│  前端   │                    │  后端   │                    │  Redis  │
└────┬────┘                    └────┬────┘                    └────┬────┘
     │                               │                               │
     │  1. POST /api/v1/send_code   │                               │
     │     {phone: "138..."}         │                               │
     ├──────────────────────────────>│                               │
     │                               │  2. 生成6位验证码             │
     │                               │  3. 存入Redis (5分钟过期)     │
     │                               ├──────────────────────────────>│
     │                               │                               │
     │  4. 返回验证码（开发环境）      │                               │
     │<──────────────────────────────┤                               │
     │                               │                               │
     │  5. POST /api/v1/login         │                               │
     │     {phone, code}              │                               │
     ├──────────────────────────────>│                               │
     │                               │  6. 从Redis读取验证码          │
     │                               ├──────────────────────────────>│
     │                               │<──────────────────────────────┤
     │                               │  7. 验证码校验                 │
     │                               │  8. 查询用户信息               │
     │                               │  9. 生成JWT Token              │
     │                               │                               │
     │  10. 返回 {user, token}        │                               │
     │<──────────────────────────────┤                               │
     │                               │                               │
     │  11. 保存Token到本地            │                               │
     │  12. 跳转到用户主页             │                               │
     │                               │                               │
```

### 2. 车辆入场流程

```
┌─────────┐                    ┌─────────┐                    ┌─────────┐
│  前端   │                    │  后端   │                    │  MySQL  │
└────┬────┘                    └────┬────┘                    └────┬────┘
     │                               │                               │
     │  1. POST /api/parking/entry   │                               │
     │     {license_plate, space_type}│                               │
     ├──────────────────────────────>│                               │
     │                               │  2. 根据车牌号查找车辆         │
     │                               ├──────────────────────────────>│
     │                               │<──────────────────────────────┤
     │                               │  3. 检查是否有有效预订         │
     │                               │     (提前30分钟允许入场)       │
     │                               ├──────────────────────────────>│
     │                               │<──────────────────────────────┤
     │                               │                               │
     │                               │  4a. 有预订：使用预订车位      │
     │                               │      更新预订状态为"使用中"    │
     │                               │  4b. 无预订：分配空闲车位      │
     │                               │                               │
     │                               │  5. 创建停车记录               │
     │                               │  6. 更新车位状态为已占用       │
     │                               ├──────────────────────────────>│
     │                               │                               │
     │  7. 返回入场信息               │                               │
     │<──────────────────────────────┤                               │
     │                               │                               │
```

### 3. 车辆离场与支付流程

```
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│  前端   │    │  后端   │    │  MySQL  │    │支付服务  │    │  Redis  │
└────┬────┘    └────┬────┘    └────┬────┘    └────┬────┘    └────┬────┘
     │              │              │              │              │
     │ 1. POST      │              │              │              │
     │ /api/parking │              │              │              │
     │ /exit        │              │              │              │
     ├─────────────>│              │              │              │
     │              │ 2. 查找在场   │              │              │
     │              │    停车记录   │              │              │
     │              ├─────────────>│              │              │
     │              │<─────────────┤              │              │
     │              │              │              │              │
     │              │ 3. 计算停车费 │              │              │
     │              │    和违规罚款 │              │              │
     │              │              │              │              │
     │              │ 4. 更新停车   │              │              │
     │              │    记录状态   │              │              │
     │              ├─────────────>│              │              │
     │              │              │              │              │
     │              │ 5. 释放车位   │              │              │
     │              ├─────────────>│              │              │
     │              │              │              │              │
     │              │ 6. 更新预订   │              │              │
     │              │    状态为完成 │              │              │
     │              ├─────────────>│              │              │
     │              │              │              │              │
     │              │ 7. 创建支付单 │              │              │
     │              ├─────────────────────────────>│              │
     │              │              │              │              │
     │              │ 8. 返回支付链接             │              │
     │<─────────────┤              │              │              │
     │              │              │              │              │
     │ 9. 打开支付   │              │              │              │
     │    页面       │              │              │              │
     │              │              │              │              │
     │ 10. 完成支付  │              │              │              │
     │     POST     │              │              │              │
     │ /api/payment │              │              │              │
     │ /notify      │              │              │              │
     ├─────────────>│              │              │              │
     │              │ 11. 更新支付  │              │              │
     │              │     记录状态   │              │              │
     │              ├─────────────>│              │              │
     │              │              │              │              │
     │              │ 12. 更新停车  │              │              │
     │              │     记录支付   │              │              │
     │              │     状态       │              │              │
     │              ├─────────────>│              │              │
     │              │              │              │              │
     │ 13. 返回成功  │              │              │              │
     │<─────────────┤              │              │              │
     │              │              │              │              │
```

### 4. 预订创建与支付流程

```
┌─────────┐                    ┌─────────┐                    ┌─────────┐
│  前端   │                    │  后端   │                    │  MySQL  │
└────┬────┘                    └────┬────┘                    └────┬────┘
     │                               │                               │
     │  1. POST /api/v4/booking/     │                               │
     │     create                    │                               │
     │     {user_id, vehicle_id,     │                               │
     │      lot_id, start_time,      │                               │
     │      end_time, space_type}    │                               │
     ├──────────────────────────────>│                               │
     │                               │  2. 查找可用车位               │
     │                               ├──────────────────────────────>│
     │                               │<──────────────────────────────┤
     │                               │  3. 创建预订订单               │
     │                               │  4. 标记车位为已预订           │
     │                               ├──────────────────────────────>│
     │                               │                               │
     │  5. 返回预订订单信息            │                               │
     │<──────────────────────────────┤                               │
     │                               │                               │
     │  6. POST /api/payment/create  │                               │
     │     {order_id, type:          │                               │
     │      "reservation", method}    │                               │
     ├──────────────────────────────>│                               │
     │                               │  7. 创建待支付记录             │
     │                               ├──────────────────────────────>│
     │                               │                               │
     │  8. 返回支付链接               │                               │
     │<──────────────────────────────┤                               │
     │                               │                               │
     │  9. 完成支付                   │                               │
     │  10. POST /api/payment/notify │                               │
     ├──────────────────────────────>│                               │
     │                               │  11. 更新支付状态              │
     │                               │  12. 更新预订订单支付状态      │
     │                               ├──────────────────────────────>│
     │                               │                               │
     │  13. 返回支付成功              │                               │
     │<──────────────────────────────┤                               │
     │                               │                               │
```

---

## 数据库设计

### 核心数据表

#### 1. 用户表 (users_list)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| user_id | uint | 主键，自增 |
| username | string(50) | 用户名，唯一 |
| password_hash | string(255) | 密码哈希值（bcrypt） |
| phone | string(20) | 手机号，索引 |
| email | string(100) | 邮箱，索引 |
| real_name | string(50) | 真实姓名 |
| register_time | datetime | 注册时间 |
| last_login | datetime | 最后登录时间 |
| status | int8 | 状态（0-禁用，1-正常） |

**关联关系**：
- 一对多：Vehicles（车辆）
- 一对多：ReservationOrder（预订订单）
- 一对多：ParkingRecord（停车记录）
- 一对多：PaymentRecord（支付记录）
- 一对多：ViolationRecord（违规记录）

#### 2. 车辆表 (vehicle)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| vehicle_id | uint | 主键，自增 |
| user_id | uint | 外键，关联用户 |
| license_plate | string(20) | 车牌号，唯一（数据库字段名） |
| LicensePlate | string(20) | 车牌号（JSON 标签，首字母大写，后端返回时使用） |
| brand | string(50) | 品牌 |
| model | string(50) | 车型 |
| color | string(20) | 颜色 |
| add_time | datetime | 添加时间 |

**注意**：后端 Vehicle 模型的 JSON 标签是 `LicensePlate`（首字母大写），前端需要兼容处理多种字段名格式（`LicensePlate`、`licensePlate`、`license_plate`）。

**关联关系**：
- 多对一：Users_list（用户）
- 一对多：ReservationOrder（预订）
- 一对多：ParkingRecord（停车记录）
- 一对多：ViolationRecord（违规记录）

#### 3. 停车场表 (parking_lot)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| lot_id | uint | 主键，自增 |
| name | string(100) | 停车场名称 |
| address | string(255) | 地址 |
| total_levels | int | 总层数 |
| total_spaces | int | 总车位数 |
| hourly_rate | decimal(10,2) | 小时费率 |
| status | int8 | 状态（0-禁用，1-启用） |
| description | text | 描述 |

**关联关系**：
- 一对多：ParkingSpace（车位）
- 一对多：ReservationOrder（预订）
- 一对多：ParkingRecord（停车记录）

#### 4. 车位表 (parking_space)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| space_id | uint | 主键，自增 |
| lot_id | uint | 外键，关联停车场 |
| level | int | 楼层 |
| space_number | string(50) | 车位编号 |
| space_type | string(20) | 车位类型（普通、充电桩、残疾人、VIP） |
| is_occupied | int8 | 是否占用（0-否，1-是） |
| is_reserved | int8 | 是否预订（0-否，1-是） |
| status | int8 | 状态（0-禁用，1-可用） |

**关联关系**：
- 多对一：ParkingLot（停车场）
- 一对多：ReservationOrder（预订）
- 一对多：ParkingRecord（停车记录）

#### 5. 预订订单表 (reservation_order)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| order_id | uint | 主键，自增 |
| user_id | uint | 外键，关联用户 |
| vehicle_id | uint | 外键，关联车辆 |
| lot_id | uint | 外键，关联停车场 |
| space_id | uint | 外键，关联车位 |
| start_time | datetime | 预订开始时间 |
| end_time | datetime | 预订结束时间 |
| duration_minutes | int | 预订时长（分钟） |
| booking_time | datetime | 预订创建时间 |
| status | int8 | 状态（0-已取消，1-已预订，2-使用中，3-已完成） |
| total_fee | decimal(10,2) | 总费用 |
| paid_fee | decimal(10,2) | 已支付费用 |
| payment_status | int8 | 支付状态（0-未支付，1-已支付） |
| reservation_code | string(50) | 预订编号 |
| actual_start_time | datetime | 实际开始时间（可选） |
| actual_end_time | datetime | 实际结束时间（可选） |

**关联关系**：
- 多对一：Users_list（用户）
- 多对一：Vehicle（车辆）
- 多对一：ParkingLot（停车场）
- 多对一：ParkingSpace（车位）
- 一对多：PaymentRecord（支付记录）

#### 6. 停车记录表 (parking_record)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| record_id | uint | 主键，自增 |
| user_id | uint | 外键，关联用户 |
| vehicle_id | uint | 外键，关联车辆 |
| space_id | uint | 外键，关联车位 |
| lot_id | uint | 外键，关联停车场 |
| entry_time | datetime | 入场时间 |
| exit_time | datetime | 出场时间（可选） |
| duration_minute | int | 停车时长（分钟） |
| fee_calculated | decimal(10,2) | 计算出的费用 |
| fee_paid | decimal(10,2) | 已支付费用 |
| payment_status | int8 | 支付状态（0-未支付，1-已支付） |
| record_status | int8 | 记录状态（1-在场，2-已出场） |
| is_violation | int8 | 是否违规（0-否，1-是） |
| violation_reason | string(255) | 违规原因 |
| create_time | datetime | 创建时间 |

**关联关系**：
- 多对一：Users_list（用户）
- 多对一：Vehicle（车辆）
- 多对一：ParkingSpace（车位）
- 多对一：ParkingLot（停车场）
- 一对多：ViolationRecord（违规记录）
- 一对多：PaymentRecord（支付记录）

#### 7. 支付记录表 (payment_record)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| payment_id | uint | 主键，自增 |
| order_id | uint | 关联订单ID（可能是预订订单、停车记录ID或违规记录ID） |
| user_id | uint | 外键，关联用户 |
| amount | decimal(10,2) | 支付金额 |
| method | string(20) | 支付方式（alipay、wechat） |
| transaction_no | string(100) | 第三方交易号 |
| payment_status | int8 | 支付状态（0-待支付，1-已支付） |
| pay_time | datetime | 支付时间（可选） |
| create_time | datetime | 创建时间 |
| refund_time | datetime | 退款时间（可选） |

**关联关系**：
- 多对一：Users_list（用户）
- 多对一：ReservationOrder（预订订单，通过order_id关联）
- 多对一：ParkingRecord（停车记录，通过order_id关联）
- 多对一：ViolationRecord（违规记录，通过transaction_no前缀识别）

#### 8. 违规记录表 (violation_record)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| violation_id | uint | 主键，自增 |
| record_id | uint | 外键，关联停车记录（可选） |
| user_id | uint | 外键，关联用户 |
| vehicle_id | uint | 外键，关联车辆 |
| violation_type | string(50) | 违规类型（超时停车、预订未使用、未支付停车费） |
| violation_time | datetime | 违规时间 |
| description | text | 违规描述 |
| fine_amount | decimal(10,2) | 罚款金额 |
| status | int8 | 处理状态（0-未处理，1-已处理） |
| create_time | datetime | 创建时间 |

**关联关系**：
- 多对一：Users_list（用户）
- 多对一：Vehicle（车辆）
- 多对一：ParkingRecord（停车记录，可选）

#### 9. 管理员表 (admins_list)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| admin_id | uint | 主键，自增 |
| username | string(50) | 登录名 |
| password_hash | string(255) | 加密密码 |
| phone_number | string(20) | 电话号码 |
| role | enum | 角色类型（system-系统管理员，lot_admin-停车场管理员） |
| lot_id | uint | 外键，关联停车场（停车场管理员专用） |
| status | int8 | 状态（0-禁用，1-启用） |
| create_time | datetime | 创建时间 |

**关联关系**：
- 多对一：ParkingLot（停车场，仅停车场管理员）

### 数据库关系图

```
┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│  Users_list  │────────▶│   Vehicle    │────────▶│ Reservation  │
│              │ 1:N     │              │ 1:N     │   Order      │
└──────────────┘         └──────────────┘         └──────────────┘
      │                        │                           │
      │                        │                           │
      │ 1:N                    │ 1:N                       │ 1:N
      │                        │                           │
      ▼                        ▼                           ▼
┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│ ParkingRecord│────────▶│ ParkingSpace │         │PaymentRecord │
│              │ N:1     │              │         │              │
└──────────────┘         └──────────────┘         └──────────────┘
      │                        │ N:1                       │
      │                        │                           │
      │ 1:N                    ▼                           │
      │                  ┌──────────────┐                   │
      │                  │ ParkingLot   │                   │
      │                  │              │                   │
      ▼                  └──────────────┘                   │
┌──────────────┐                                            │
│ Violation    │────────────────────────────────────────────┘
│   Record     │
└──────────────┘
```

---

## 核心业务逻辑

### 1. 预订业务逻辑

#### 1.1 预订创建流程

```
用户提交预订请求
    ↓
验证参数（时间、车辆、停车场）
    ↓
查找可用车位（FindAvailableSlot）
    ├─ 条件：lot_id、space_type、is_occupied=0、is_reserved=0、status=1
    └─ 返回第一个可用车位
    ↓
验证时间有效性
    ├─ end_time > start_time
    └─ duration > 0
    ↓
计算预订费用（根据时长和费率）
    ↓
创建预订订单（ReservationOrder）
    ├─ status = 1（已预订）
    ├─ payment_status = 0（未支付）
    └─ 生成预订编号（RES-{userID}-{timestamp}）
    ↓
标记车位为已预订（is_reserved = 1）
    ↓
返回预订订单信息
```

#### 1.2 预订状态流转

```
已预订（status=1）
    ↓
    ├─ 车辆入场 → 使用中（status=2）
    │   └─ 更新 actual_start_time
    │
    ├─ 用户取消 → 已取消（status=0）
    │   └─ 释放车位（is_reserved=0）
    │
    └─ 时间过期 → 已取消（status=0）
        └─ 自动检查并更新（check-expired接口）
            ↓
使用中（status=2）
    ↓
    └─ 车辆离场 → 已完成（status=3）
        └─ 更新 actual_end_time
```

### 2. 停车业务逻辑

#### 2.1 车辆入场流程

```
用户提交入场请求（车牌号、车位类型、停车场ID）
    ↓
查找车辆信息（根据车牌号）
    ↓
检查是否有有效预订
    ├─ 查找条件：
    │   ├─ vehicle_id 匹配
    │   ├─ lot_id 匹配（如果提供）
    │   ├─ status = 1（已预订）
    │   └─ 当前时间在预订时间段内（允许提前30分钟）
    │
    ├─ 有有效预订：
    │   ├─ 使用预订的车位（space_id）
    │   ├─ 更新预订状态为"使用中"（status=2）
    │   └─ 设置 actual_start_time
    │
    └─ 无有效预订：
        ├─ 查找可用车位（FindAvailableSlot）
        └─ 分配空闲车位
    ↓
创建停车记录（ParkingRecord）
    ├─ record_status = 1（在场）
    ├─ payment_status = 0（未支付）
    └─ 记录入场时间
    ↓
标记车位为已占用（is_occupied = 1）
    ↓
返回停车记录信息
```

#### 2.2 车辆离场流程

```
用户提交离场请求（车牌号）
    ↓
查找在场停车记录（record_status=1）
    ↓
计算停车费用
    ├─ 停车时长 = 当前时间 - entry_time
    ├─ 停车费 = ceil(时长/小时) × hourly_rate
    └─ 向上取整（不足1小时按1小时计）
    ↓
检查违规记录
    ├─ 查询 ViolationRecord（record_id 匹配）
    ├─ 计算违规罚款总额
    └─ 总费用 = 停车费 + 违规罚款
    ↓
开始数据库事务
    ↓
更新停车记录
    ├─ exit_time = 当前时间
    ├─ duration_minute = 计算出的时长
    ├─ fee_calculated = 计算出的费用
    ├─ record_status = 2（已出场）
    └─ is_violation = 是否有违规
    ↓
释放车位（is_occupied = 0）
    ↓
处理关联预订
    ├─ 查找关联的预订订单（vehicle_id + entry_time 匹配）
    ├─ 更新预订状态为"已完成"（status=3）
    └─ 设置 actual_end_time
    ↓
创建支付单（通过支付服务）
    ├─ type = "parking"
    ├─ order_id = record_id
    └─ amount = 总费用
    ↓
提交事务
    ↓
返回离场信息和支付链接
```

### 3. 支付业务逻辑

#### 3.1 统一支付接口逻辑

```
用户请求创建支付（order_id、type、method、amount）
    ↓
根据 type 分支处理：
    ├─ type = "reservation"：
    │   ├─ 查询 ReservationOrder
    │   ├─ 验证订单状态（未支付、未取消）
    │   ├─ 金额 = amount 或 order.total_fee
    │   └─ 调用 bookingSvc.CreatePendingPayment()
    │
    ├─ type = "parking"：
    │   ├─ 查询 ParkingRecord
    │   ├─ 金额 = amount 或 record.fee_calculated
    │   └─ 使用原生SQL创建支付记录（临时禁用外键）
    │
    └─ type = "violation"：
        ├─ 查询 ViolationRecord
        ├─ 验证状态（未处理）
        ├─ 金额 = amount 或 violation.fine_amount
        └─ 使用原生SQL创建支付记录
    ↓
创建 PaymentRecord
    ├─ payment_status = 0（待支付）
    ├─ transaction_no = 临时唯一值
    └─ 根据type设置不同的前缀：
        ├─ reservation: 无特殊前缀
        ├─ parking: PENDING_{record_id}_{timestamp}
        └─ violation: PENDING_VIO_{violation_id}_{timestamp}
    ↓
生成支付链接
    └─ URL: http://127.0.0.1:8081/simulate_payment?provider={method}&payment_id={payment_id}
    ↓
返回支付链接和 payment_id
```

#### 3.2 支付回调逻辑

```
支付平台回调（payment_id、amount、transaction_no、provider）
    ↓
查询支付记录
    ↓
检查支付状态
    ├─ 已支付（payment_status=1）→ 直接返回成功（幂等性）
    └─ 未支付 → 继续处理
    ↓
验证交易号唯一性（避免重复支付）
    ↓
更新支付记录
    ├─ payment_status = 1（已支付）
    ├─ transaction_no = 回调的交易号
    ├─ method = provider
    ├─ amount = 回调金额
    └─ pay_time = 当前时间
    ↓
根据 transaction_no 前缀判断订单类型
    ├─ 前缀 = "PENDING_VIO_"：
    │   ├─ 查找 ViolationRecord
    │   └─ 更新违规记录状态为"已处理"（status=1）
    │
    ├─ 前缀 = "PENDING_" 或无前缀：
    │   ├─ 尝试查找 ReservationOrder（通过 order_id）
    │   │   └─ 调用 bookingSvc.PayBooking()
    │   │       ├─ 更新订单 payment_status=1
    │   │       └─ 更新 paid_fee
    │   │
    │   └─ 尝试查找 ParkingRecord（通过 order_id）
    │       ├─ 更新记录 payment_status=1
    │       └─ 更新 fee_paid
    ↓
返回成功结果
```

### 4. 违规检查逻辑

#### 4.1 违规类型

1. **预订未使用**（check_type=1）：
   - 查找条件：预订时间已过（end_time < 当前时间）
   - 状态：status = 1（已预订）且未入场
   - 处理：创建违规记录，更新预订状态为"已取消"

2. **超时停车**（check_type=2）：
   - 查找条件：停车记录关联了预订，且停车时间超过预订结束时间
   - 处理：创建违规记录，计算超时罚款

3. **未支付停车费**（check_type=3）：
   - 查找条件：停车记录已离场（record_status=2）且未支付（payment_status=0）
   - 处理：创建违规记录

4. **未支付罚款**（check_type=4）：
   - 查找条件：违规记录未处理（status=0）且超过一定时间
   - 处理：可发送提醒或升级处理

### 5. 数据统计逻辑

#### 5.1 车位使用率分析

**实现逻辑**：
```
查询指定停车场和时间范围
    ↓
统计指标计算：
    ├─ 总车位数 = 查询 ParkingSpace 表（lot_id 匹配）
    │
    ├─ 已占用车位数 = 查询在时间段内有停车记录的车位
    │   └─ 条件：entry_time <= end_time AND (exit_time >= start_time OR exit_time IS NULL)
    │
    ├─ 已预订车位数 = 查询在时间段内有有效预订的车位
    │   └─ 条件：start_time <= end_time AND end_time >= start_time AND status = 1
    │
    ├─ 使用率 = (已占用车位数 / 总车位数) × 100%
    │
    ├─ 总收入 = SUM(fee_paid) from ParkingRecord
    │   └─ 条件：entry_time BETWEEN start_time AND end_time
    │
    ├─ 日均收入 = 总收入 / 时间范围天数
    │
    ├─ 平均停车时长 = AVG(duration_minute) / 60（转换为小时）
    │
    └─ 按车位类型分组统计
        ├─ 普通车位：总数、已占用数
        ├─ 充电桩车位：总数、已占用数
        └─ 其他类型：总数、已占用数
    ↓
返回统计数据（JSON格式）
```

**数据查询实现**：
- **文件**：`smart_parking_backend/internal/controller/admin_analysis_controller.go`
- **函数**：`getParkingOccupancyStats()`
- **查询方式**：
  1. 使用 GORM 查询 ParkingSpace 表统计总车位数
  2. 使用子查询统计已占用车位数（通过 ParkingRecord）
  3. 使用子查询统计已预订车位数（通过 ReservationOrder）
  4. 使用聚合函数计算收入、平均时长等指标
  5. 使用 GROUP BY 按车位类型分组统计

#### 5.2 违规行为分析

**实现逻辑**：
```
查询指定年份和月份的违规记录
    ↓
统计指标计算：
    ├─ 违规总数 = COUNT(*) from ViolationRecord
    │   └─ 条件：year(violation_time) = year AND month(violation_time) = month
    │
    ├─ 按违规类型分组统计
    │   ├─ 超时停车：COUNT(*) WHERE violation_type = "超时停车"
    │   ├─ 预订未使用：COUNT(*) WHERE violation_type = "预订未使用"
    │   └─ 未支付停车费：COUNT(*) WHERE violation_type = "未支付停车费"
    │
    ├─ 按处理状态分组统计
    │   ├─ 未处理：COUNT(*) WHERE status = 0
    │   └─ 已处理：COUNT(*) WHERE status = 1
    │
    ├─ 罚款总额 = SUM(fine_amount)
    │
    ├─ 已收罚款 = SUM(fine_amount) WHERE status = 1
    │
    └─ 月度趋势分析
        └─ 按月份分组统计违规数量和罚款金额
    ↓
返回统计数据（JSON格式）
```

**数据查询实现**：
- **函数**：`ViolationAnalysis()`
- **查询方式**：
  1. 使用时间函数（YEAR、MONTH）过滤违规记录
  2. 使用 GROUP BY 按违规类型和处理状态分组
  3. 使用聚合函数（COUNT、SUM）计算统计指标
  4. 使用子查询或窗口函数计算月度趋势

#### 5.3 报表生成逻辑

**实现逻辑**：
```
根据报表类型（monthly/annual）和时间范围查询数据
    ↓
收集各类统计数据：
    ├─ 停车统计
    │   ├─ 总停车次数 = COUNT(*) from ParkingRecord
    │   ├─ 总停车时长 = SUM(duration_minute) / 60（小时）
    │   └─ 总收入 = SUM(fee_paid)
    │
    ├─ 违规统计
    │   ├─ 违规总数 = COUNT(*) from ViolationRecord
    │   └─ 罚款总额 = SUM(fine_amount)
    │
    ├─ 收入统计
    │   ├─ 总收入 = SUM(fee_paid) from ParkingRecord + SUM(fine_amount) from ViolationRecord
    │   ├─ 日均收入 = 总收入 / 天数
    │   └─ 峰值时段分析
    │       └─ 按小时分组统计收入，找出收入最高的时段
    │
    ├─ 使用率统计
    │   ├─ 平均使用率 = AVG(每日使用率)
    │   └─ 峰值使用率 = MAX(每日使用率)
    │
    └─ 高峰时段分析
        └─ 按小时分组统计停车次数，找出停车高峰时段
    ↓
生成报表数据（JSON格式）
    ├─ 报表类型
    ├─ 时间范围
    ├─ 生成时间
    └─ 各项统计数据
```

**数据查询实现**：
- **函数**：`GenerateReport()`
- **查询方式**：
  1. 根据报表类型确定时间范围（月度或年度）
  2. 使用多个聚合查询收集各类统计数据
  3. 使用时间函数（HOUR、DATE）进行时段分析
  4. 组合所有统计数据生成完整报表

---

## 总结

### 技术架构总结

本智能停车系统采用前后端分离架构：

- **后端**：Go + Gin + GORM + MySQL + Redis
  - RESTful API 设计
  - JWT 认证机制
  - 分层架构（Controller → Service → Repository）
  - 事务管理确保数据一致性

- **前端**：Qt6 + QML + C++
  - 跨平台桌面应用
  - 声明式 UI（QML）
  - 网络请求封装（ApiClient）
  - 状态管理（AuthManager）

### 核心业务流程总结

1. **用户认证流程**：注册 → 登录（密码/验证码）→ JWT Token → 后续请求携带 Token
2. **预订流程**：创建预订 → 支付 → 车辆入场（使用预订车位）→ 车辆离场 → 完成预订
3. **停车流程**：车辆入场（检查预订/分配车位）→ 停车中 → 车辆离场 → 计算费用 → 支付
4. **支付流程**：创建支付单 → 跳转支付页面 → 支付回调 → 更新订单状态
5. **违规处理**：自动检测违规 → 生成违规记录 → 用户支付罚款 → 更新违规状态

### 数据一致性保证

1. **事务管理**：关键操作（如车辆离场）在数据库事务中执行
2. **状态同步**：预订状态、车位状态、支付状态实时同步
3. **级联删除**：使用 GORM 外键约束确保数据完整性
4. **幂等性**：支付回调接口支持重复调用（已支付直接返回成功）

### 性能优化

1. **数据库索引**：在关键字段（user_id、vehicle_id、lot_id、phone 等）上建立索引
2. **Redis 缓存**：验证码、会话信息使用 Redis 存储
3. **查询优化**：使用预加载（Preload）减少数据库查询次数
4. **分页查询**：支付记录等列表数据支持分页

### 安全机制

1. **密码加密**：使用 bcrypt 算法加密存储
2. **JWT 认证**：用户和管理员使用不同的 JWT Secret
3. **中间件验证**：所有需要认证的接口都经过中间件验证
4. **参数验证**：控制器层进行参数校验和业务规则验证

### 扩展性设计

1. **模块化设计**：预订、支付、违规等模块独立实现
2. **统一支付接口**：支持多种订单类型（预订、停车、违规）
3. **管理员角色**：支持系统管理员和停车场管理员两种角色
4. **车位类型**：支持普通、充电桩、残疾人、VIP 等多种类型

---

## 附录

### 关键文件清单

**后端关键文件**：
- `smart_parking_backend/main.go` - 程序入口
- `smart_parking_backend/routers/router.go` - 路由配置
- `smart_parking_backend/internal/controller/` - 控制器层
- `smart_parking_backend/internal/service/` - 服务层（booking、payment）
- `smart_parking_backend/internal/model/models.go` - 数据模型
- `smart_parking_backend/internal/middleware/` - 中间件（认证、CORS）
- `smart_parking_backend/config/config.yaml` - 配置文件

**前端关键文件**：
- `smartparkingui/src/main.cpp` - 程序入口
- `smartparkingui/src/apiclient.cpp` - API 客户端
- `smartparkingui/src/authmanager.cpp` - 认证管理
- `smartparkingui/include/` - 头文件
- `smartparkingui/ui/` - QML 界面文件
- `smartparkingui/CMakeLists.txt` - 构建配置

### API 接口汇总

**用户接口**（`/api/v1`）：
- `POST /api/v1/register` - 用户注册
- `POST /api/v1/login` - 用户登录
- `POST /api/v1/send_code` - 发送验证码
- `GET /api/v1/vehicles` - 获取车辆列表
- `POST /api/v1/vehicles` - 添加车辆
- `DELETE /api/v1/vehicles/:id` - 删除车辆
- `GET /api/v1/getpaymentinfo` - 获取支付记录

**管理员接口**（`/admin`）：
- `POST /admin/login` - 管理员登录
- `GET /admin/occupancy` - 车位使用率分析
- `GET /admin/violations` - 违规行为分析
- `GET /admin/report` - 报表生成

**停车场接口**（`/api/v2`）：
- `GET /api/v2/getparkinglots` - 获取停车场列表
- `POST /api/v2/addparkinglot` - 添加停车场
- `POST /api/v2/addparkingspace` - 添加车位
- `PATCH /api/v2/updatespacestatus/:id` - 更新车位状态

**预订接口**（`/api/v4/booking`）：
- `POST /api/v4/booking/create` - 创建预订
- `DELETE /api/v4/booking/cancel/:id` - 取消预订
- `GET /api/v4/booking/user` - 获取用户预订列表
- `POST /api/v4/booking/check-expired` - 检查超时预订

**停车接口**（`/api/parking`）：
- `POST /api/parking/entry` - 车辆入场
- `POST /api/parking/exit` - 车辆离场
- `POST /api/parking/check-reservation` - 检查有效预订
- `GET /api/parking/:user_id/active-parking` - 获取在场停车记录

**支付接口**（`/api/payment`）：
- `POST /api/payment/create` - 创建支付
- `POST /api/payment/notify` - 支付回调

**违规模块**（`/api/violations`）：
- `GET /api/violations/checkmyself/:user_id` - 查询用户违规记录
- `POST /api/violations/:violation_id/pay` - 支付罚款

---